<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tennis Shot DSL – Full Interactive</title>

<style>






#main {
  display: flex;
  align-items: center;
}

#tactics {
  width: 220px;
  background: #0f3d22;
  color: #fff;
  padding: 10px;
  margin-right: 10px;
}

.tactic-btn {
  padding: 8px;
  margin-bottom: 6px;
  background: #1b5e20;
  cursor: pointer;
  transition: background 0.2s;
}

.tactic-btn:hover {
  background: #2e7d32;
}

#modalOverlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.6);
  display: none;
  justify-content: center;
  align-items: center;
}

#modal {
  background: #fff;
  color: #000;
  width: 60%;
  max-width: 90%;
  padding: 20px;
}

#modal img, #modal iframe {
  width: 100%;
  height: 60%;
  border: none;
}









body {
  margin: 0;
  padding: 0;
  background: #1b5e20;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

canvas {
  background: #2e7d32;
  border: 4px solid #ffffff;
  margin-top: 10px;
}

#editorContainer {
  width: 100%;
  display: flex;
  justify-content: center;   /* ✅ horizontal centering */
  margin-top: 10px;
}

#panel {
  width: 900px;              /* same width as court */
  background: #0f3d22;
  color: #fff;
  padding: 10px;
  box-sizing: border-box;
}


textarea {
  width: 100%;
  height: 120px;
  box-sizing: border-box;
  font-family: monospace;
  font-size: 14px;
}

button {
  margin-top: 6px;
  margin-right: 6px;
  padding: 6px 12px;
  font-size: 14px;
  cursor: pointer;
}

#status {
  margin-top: 6px;
  font-size: 13px;
}
</style>
</head>
<body>

<div id="main">
  <div id="tactics"></div>
  <canvas id="court" width="900" height="450"></canvas>
</div>

<div id="editorContainer">
  <div id="panel">
    <strong>Shot Script (one per line)</strong>
    <textarea id="editor">
n,a,d'
l,a,bc'
s,a,sa'b'
d,sc',c
sm,sa,sa'b'
    </textarea>

    <div>
      <button onclick="loadShots()">Load / Validate</button>
      <button onclick="togglePlay()">Play / Pause</button>
      <button onclick="resetAnim()">Reset</button>
    </div>

    <div id="status">Status: ready</div>
  </div>
</div>

<script>
/* =====================
  GEOMETRY
===================== */
const canvas = document.getElementById("court");
const ctx = canvas.getContext("2d");

const W = canvas.width;
const H = canvas.height;
const segH = H / 4;

const leftBaseline = 40;
const rightBaseline = W - 40;
const netX = W / 2;

// Service lines midway between baseline and net
const leftService = (leftBaseline + netX) / 2;
const rightService = (rightBaseline + netX) / 2;

const segments = ["a", "b", "c", "d"];
const effects = ["n", "l", "s", "d", "sm"];

/* =====================
  STATE
===================== */
let shots = [];
let path = [];
let shotIndex = 0;
let playing = true;
let highlightedZones = [];

const ball = { x: 0, y: 0, i: 0 };

/* =====================
  POINT RESOLUTION
===================== */
function singlePoint(token) {
  let side = "left";
  let service = false;

  if (token.includes("'")) side = "right";
  token = token.replace("'", "");

  if (token.startsWith("s")) {
    service = true;
    token = token.slice(1);
  }

  const idx = segments.indexOf(token);
  if (idx === -1) throw "Invalid point";

  const y = idx * segH + segH / 2;
  let x = side === "left" ? leftBaseline : rightBaseline;
  if (service) x = side === "left" ? leftService : rightService;

  return { x, y };
}

function resolveToken(token) {
  const parts = token.match(/s?[abcd]'?/g);
  if (!parts || parts.length === 0 || parts.length > 2) {
    throw "Invalid token: " + token;
  }

  if (parts.length === 1) return singlePoint(parts[0]);

  const p1 = singlePoint(parts[0]);
  const p2 = singlePoint(parts[1]);
  return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
}



function parseZone(zoneStr) {
  // matches a, b', sa, sa', etc.
  return zoneStr.match(/s?[abcd]'?/g).map(resolveToken);
}

function drawZones() {
  ctx.fillStyle = "rgba(255,255,0,0.25)";
  highlightedZones.forEach(zone => {
    const pts = parseZone(zone);
    if (pts.length < 3) return;

    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (let i = 1; i < pts.length; i++) {
      ctx.lineTo(pts[i].x, pts[i].y);
    }
    ctx.closePath();
    ctx.fill();
  });
}




/* =====================
  PATH
===================== */
function buildPath(from, to, effect) {
  const p0 = resolveToken(from);
  const p1 = resolveToken(to);

  const steps = effect === "sm" ? 60 : 120;
  const curve = [];

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    let x = p0.x + (p1.x - p0.x) * t;
    let y = p0.y + (p1.y - p0.y) * t;

    if (effect === "l") y -= 140 * Math.sin(Math.PI * t);
    if (effect === "s") y += 40 * Math.sin(Math.PI * t);
    if (effect === "d") y -= 70 * Math.sin(Math.PI * t) * (1 - t);
    if (effect === "sm") y += 20 * Math.sin(Math.PI * t);

    curve.push({ x, y });
  }
  return curve;
}

/* =====================
  UI / VALIDATION
===================== */
function setStatus(msg, ok=true) {
  document.getElementById("status").innerText = "Status: " + msg;
  document.getElementById("status").style.color = ok ? "#9cff9c" : "#ff9c9c";
}

function loadShots() {
  try {
    const lines = document.getElementById("editor").value
      .split("\n")
      .map(l => l.trim())
      .filter(l => l.length);

    shots = lines.map(line => {
      const parts = line.split(",");
      if (parts.length !== 3) throw "Bad format: " + line;
      if (!effects.includes(parts[0])) throw "Bad effect: " + parts[0];
      resolveToken(parts[1]);
      resolveToken(parts[2]);
      return parts;
    });

    shotIndex = 0;
    nextShot();
    setStatus("Loaded OK (" + shots.length + " shots)");
  } catch (e) {
    setStatus("Error: " + e, false);
  }
}

/* =====================
  DRAWING
===================== */
function drawCourt() {
  ctx.clearRect(0, 0, W, H);
  ctx.strokeStyle = "#fff";
  ctx.lineWidth = 2;

drawZones();



  [leftBaseline, rightBaseline, leftService, rightService, netX].forEach(x => {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  });

  // Horizontal connector between service-line centers
  ctx.beginPath();
  ctx.moveTo(leftService, H / 2);
  ctx.lineTo(rightService, H / 2);
  ctx.stroke();

  drawLabels();
}

function drawLabels() {
  ctx.fillStyle = "#fff";
  ctx.font = "14px Arial";

  segments.forEach((s, i) => {
    const y = i * segH + segH / 2;
    ctx.fillText(s, leftBaseline - 25, y);
    ctx.fillText("s" + s, leftService - 30, y);
    ctx.fillText("s" + s + "'", rightService + 10, y);
    ctx.fillText(s + "'", rightBaseline + 10, y);
  });
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, 6, 0, Math.PI * 2);
  ctx.fillStyle = "#fdd835";
  ctx.fill();
}

/* =====================
  ANIMATION
===================== */
function nextShot() {
  if (!shots.length) return;
  const [effect, from, to] = shots[shotIndex];
  path = buildPath(from, to, effect);
  ball.i = 0;
  ball.x = path[0].x;
  ball.y = path[0].y;
}

function togglePlay() {
  playing = !playing;
}

function resetAnim() {
  shotIndex = 0;
  nextShot();
}

function animate() {
  drawCourt();
  drawBall();

  if (playing && path.length) {
    ball.i++;
    if (ball.i < path.length) {
      ball.x = path[ball.i].x;
      ball.y = path[ball.i].y;
    } else {
      shotIndex = (shotIndex + 1) % shots.length;
      nextShot();
    }
  }

  requestAnimationFrame(animate);
}



/* =====================
   TACTICS DATA
===================== */
const tactics = [
  { name: "Baseline Play", text: "Open Space trap opponent outside the court-variations 1-1,2-1,3-1", media: "img/Baseline_for_simulator.jpg",
    script: [
      "n,a,c'",
      "n,c',b",
      "n,b,d'",
      "n,d',c",
      "n,c,a'",
    ],
    zones: ["ac'd'b"] },
  { name: "Chip and Charge", text: "After serve move forward deep down the line or cross court", media: "img/Chip and Charge 2.jpg",
    script: [
      "n,d',b",
      "n,b,b''",
      "n,d',b",
      "n,b,sa'sb'",

    ],
    zones: ["ab'd'c"] },
  { name: "Crosscourt Play", text: "Try to hit deep in the corners till you get a short ball to attack,reduce risk force opponent to miss", media: "img/Cross-Court Play 2.jpg",
    script: [
      "n,a,d'",
      "n,d',b",
      "n,b,c'", 
      "n,c',b",
      "n,b,d'",
      "n,d',sasb",
      "n,sasb,a'",

    ],
    zones: ["ab'd'c"] },
  { name: "Doubles Positioning", text: "Description here", media: "",
    script: [
      "n,a,d'",
      "n,d',a"
    ],
    zones: ["ab'd'c"] },
  { name: "Down the Line", text: "When you kept opponent crosscourt, you are well balanced near middle of the court and baseline, combine it with moving toward the net, avoid it from far behind the baseline ", media: "img/Down the Line 2.jpg",
    script: [
      "n,a,d'",
      "n,d',sba",
      "n,sba,a'"
    ],
    zones: ["ab'd'c"] },
  { name: "Inside-Out Forehand", text: "The ball is slightly to the middle of the court or slightly to your backhand you hit it not with backhand you position yourself to hit it crosscourt with your forehand", media: "img/Inside-Out Forehand 2.jpg",
    script: [
      "n,b',bsb",
      "n,bsb,d'"
    ],
    zones: ["ab'd'c"] },
  { name: "Lob and Smash", text: "Your opponent makes a lob that you can exploit to make a smash, be calm concentrate to hit well above your head the ball to smash or return with a lob", media: "img/Lob and Smash 2.jpg",
    script: [
      "l,a'b',c",
      "l,c,b'c'",
      "l,b'c',dsd",
      "sm,dsd,sc'",
    ],
    zones: ["ab'd'c"] },
  { name: "Serve and Volley", text: "After serve you go to volley, chose different direction from opponents forehand, look for the free uncovered spaces", media: "img/Serve and Volley 5.jpg",
    script: [
      "n,c,c'",
      "n,c',sb",
      "n,sb,c'd'",
    ],
    zones: ["ab'd'c"] },
  { name: "The Drop Shot", text: "after quick rallies and when the opponent is slow", media: "img/The Drop Shot 3.jpg",
    script: [
      
      "d,asa,sd'"
      
    ],
    zones: ["ab'd'c"] }
];

/* =====================
   TACTICS UI
===================== */
const tacticsDiv = document.getElementById("tactics");

tactics.forEach(t => {
  const btn = document.createElement("div");
  btn.className = "tactic-btn";
  btn.innerText = t.name;
  btn.onclick = () => openModal(t);
  tacticsDiv.appendChild(btn);
});

function openModal(tactic) {
  document.getElementById("modalTitle").innerText = tactic.name;
  document.getElementById("modalText").innerText = tactic.text;

  // Load script into editor
  if (tactic.script && tactic.script.length) {
    document.getElementById("editor").value = tactic.script.join("\n");
    loadShots();
    resetAnim();
  }

  // Highlight zones
  highlightedZones = tactic.zones || [];

  const mediaDiv = document.getElementById("modalMedia");
  mediaDiv.innerHTML = "";

  if (tactic.media.endsWith(".pdf")) {
    const iframe = document.createElement("iframe");
    iframe.src = tactic.media;
    mediaDiv.appendChild(iframe);
  } else if (tactic.media) {
    const img = document.createElement("img");
    img.src = tactic.media;
    mediaDiv.appendChild(img);
  }

  document.getElementById("modalOverlay").style.display = "flex";
}


function closeModal() {
  highlightedZones = [];
  document.getElementById("modalOverlay").style.display = "none";
}







/* INIT */
loadShots();
animate();










</script>



<div id="modalOverlay" onclick="closeModal()">
  <div id="modal" onclick="event.stopPropagation()">
    <h2 id="modalTitle"></h2>
    <p id="modalText"></p>
    <div id="modalMedia"></div>
    <button onclick="closeModal()">Close</button>
  </div>
</div>
</body>
</html>